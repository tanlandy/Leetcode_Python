# DP

# 基础知识

## Intro

Dynamic programming is an algorithmic optimization technique that breaks down a complicated problem into smaller overlapping subproblems in a recursive manner and use solutions to the subproblems to construct solution to the original problem.

DP ~= Careful brute force
DP ~= subproblems + reuse -> for graph, should be acylic
DP ~= Recursion + Memo + GUESSING

- memoize
- reuse
- to subproblems that can solve the problem
Time: # of subproblems * time/subproblem

-> It is a simple concept of solving bigger problems using smaller problems while saving results to avoid repeated calculations.

1. The problem can be broken down into `"overlapping subproblems"` - smaller versions of the original problem that are re-used multiple times. -> subproblems are dependent
2. The problem has an `"optimal substructure"` - an optimal solution can be formed from optimal solutions to the overlapping subproblems of the original problem.

### Characteristics of DP

1. Optimal substructure: the problem can be divided into subproblems. And its optimal solution can be constructed from optimal solutions of the subproblems
2. The subproblems overlap

1. 无后效性
   - 一旦f(i, j)确定，就不用关心是如何计算出来的f(i, j)
   - 过去不依赖将来，将来不影响过去
2. 最优子结构
   - 大问题的最优解可以由若干个小问题的最优解推出

### Greedy vs DP

In greedy, we always want to choose the best answer
DP: is not always necessarily the best answer for every state

## When to use

DP is an **optimization** method on one or more **sequences**.

1. The problem asks for the maximum/longest, minimal/shortest value/cost/profit you can get from doing operations on a sequence.
2. You've tried greedy but it sometimes gives the wrong solution. This often means you have to consider subproblems for an optimal solution.
3. The problem asks for how many ways there are to do something. This can often be solved by DFS + memoization, i.e. top-down dynamic programming.
4. Partition a string/array into sub-sequences so that a certain condition is met. This is often well-suited for top-down dynamic programming.
5. The problem is about the optimal way to play a game.
6. Future decisions depend on earlier decision
   - House Robber
   - LIS

## How to use

1. Top-down: DFS + Memoization: split large problems and recursively solve smaller subproblems
   - draw the tree
   - identify states
    1. 站在节点：需要什么来解决问题，如何解决
    2. 站在节点：需要什么信息来确定如何往下走
   - DFS + Memoization
     - memoizing a result means to store the result of a function call, usually in a hashmap or an array,
2. Bottom-up: solve subproblmes first, and then use their solution to find the solutions to bigger subproblems -> normally done in a tabular form -> start at the base case
   - exact same computation as DFS + Memo
   - (Topological sort of subproblem dependency DAG)
   - 找到recurrence relation，例如dp[i] = dp[i-1] + dp[i-2]
   - Can often save space

## How to use

不论top-down还是bottom-up，都要思考

1. A function or data structure that will compute/contain the answer to the problem for every given state

2. A recurrence relation to transition between states: A state is a set of variables that can `sufficiently` describe a scenario. These variables are called state variables
`finding the recurrence relation is the most difficult part of solving a DP problem`

3. Bases cases
What state(s) can I find the answer to without using dynamic programming?

动态规划的一般形式就是求最值，求最值的核心就是穷举
-> 列出正确的**状态转移方程**，从而正确地穷举
-> 利用**最优子结构**，通过子问题的最值得到原问题的最值
-> 利用DP Table，优化**重叠子问题**的穷举过程

框架：

```py
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

### 5 steps to DP

1. Define subproblems -> number of subproblems
2. Guess(part of solution) -> choice of guess
3. relate subproblem solutions -> time/subproblem
4. recurse + Memo OR bottom-up tables -> check subproblem recurrence is acyclic
5. solve the original problem

# 高频题

## 知乎

## Krahets精选题

## AlgoMonster

## Youtube

[62. 不同路径]
[70. 爬楼梯]
[198. 打家劫舍]/[213. 打家劫舍 II]
[300. 最长递增子序列]
[322. 零钱兑换]

# Problems

## Sequence时间序列型

dp[i] normally means max/min/best value of the sequnce ending at index i
给出一个序列，其中每一个元素可以认为“一天”，并且“今天”的状态只取决于“昨天”的状态

### 模版

1. 定义dp[i][j]表示第i轮的第j种状态
2. 千方百计找出来dp[i][j]与前一轮dp[i-1][j]的关系（状态转移）
3. 最终结果是dp[-1][j]中的某种aggregation(sum, max, min, ...)

状态的设计：to do or NOT to do

一般一层循环，时间O(N)

### 例题

[118. Pascal's Triangle](https://leetcode.cn/problems/pascals-triangle/)

```py
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        """
        每一行的数和上一行的关系：每一个行的新数是上一行相邻两个数的和
        """
        triangle = []
        
        for row_idx in range(numRows):
            row = [None for _ in range(row_idx + 1)]
            row[0] = row[-1] = 1
            
            for j in range(1, len(row) - 1):
                row[j] = triangle[row_idx - 1][j - 1] + triangle[row_idx - 1][j]
            triangle.append(row)
        
        return triangle
```

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        """

        dp[i] means the max value we can get using elements from idx 0 up to i
        dp[i] = max(dp[i-2]+nums[i], dp[i-1]): the current dp[i] is determined by whether add this nums[i] or not

        Time: O(N)
        Space: O(N)
        """
        if len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-2] + nums[i], dp[i-1])
        
        return dp[-1]
```

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        """
        BF: list all combinations using decision tree
        Identify subproblems: if choose nums[0], then find the max from nums[2] to the end; else, find the max from nums[1:]
        rob = max(nums[0] + rob[2:], rob[1:])
        dp from the beginning to the end, each time only consider the larger one using two variables

        Time: O(N)
        Space: O(1)
        """
        rob1, rob2 = 0, 0

        # [rob1, rob2, n, n + 1, ...]
        for n in nums:
            # calc the max up until n
            tmp = max(n + rob1, rob2)
            rob1 = rob2
            rob2 = tmp
        
        return rob2
```

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        """
        dp[i] maximum money I can get ending at index i
        每一轮的状态：抢， 不抢
        抢了的话->下轮不能抢
        不抢的话->下轮可抢也可以不抢
        dp[i][0] 表示抢
        dp[i][1] 表示不抢
        站在index i：
        1. dp[i][0] = dp[i-1][1] + nums[i] 抢了
        2. dp[i][1] = max(dp[i-1][0], dp[i-1][1]) 不抢
        """
        
        dp = [[0, 0] for _ in range(len(nums))]
        
        for i in range(len(nums)):
            dp[i][0] = dp[i-1][1] + nums[i]
            dp[i][1] = max(dp[i-1][0], dp[i-1][1])
        
        return max(dp[-1][0], dp[-1][1])

        """
        nums = [1, 2, 2, 1]
        dp:
        idx     num    0(rob)  1(not rob)
        0       1       1       0
        1       2       2       1             
        2       3       4       2       
        3       1       3       4
        
        nums = [2, 7, 9, 3, 1]
        num     0(rob)  1(not rob)
        2       2       0
        7       2       2
        9       11      2
        3       5       11
        1       12      11
        """
```

[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

```python

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def one_way(cur_nums):
            if len(cur_nums) == 1:
                return cur_nums[0]
            dp = [0] * len(cur_nums)
            dp[0] = cur_nums[0]
            dp[1] = max(cur_nums[0], cur_nums[1])

            for i in range(2, len(cur_nums)):
                dp[i] = max(dp[i - 2] + cur_nums[i], dp[i - 1])
            return dp[-1]
        
        a = one_way(nums[1:])
        b = one_way(nums[:-1])
        return max(a, b)

```

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        """
        only restriction is cannot use nums[0] and nums[-1] at the same time: 
        run the LC198 two times  on nums[0:-2] and nums[1:-1], return the max of these 

        Time: O(N)
        Space: O(1)
        """
        if len(nums) == 1:
            return nums[0]

        res1 = self.helper(nums[0: -1])
        res2 = self.helper(nums[1:])
        return max(res1, res2)

    def helper(self, nums):
        rob1, rob2 = 0, 0

        for n in nums:
            tmp = max(rob1 + n, rob2)
            rob1 = rob2
            rob2 = tmp
        
        return rob2
```

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        
        def one_way(nums):
            dp = [[0, 0] for i in range(len(nums))]
            
            for i in range(len(nums)):
                dp[i][0] = dp[i-1][1] + nums[i]
                dp[i][1] = max(dp[i-1][0], dp[i-1][1])
            
            return max(dp[-1][0], dp[-1][1])
        
        res1 = one_way(nums[1:])
        res2 = one_way(nums[:-1])
        
        return max(res1, res2)
```

[376. Wiggle Subsequence](https://leetcode.cn/problems/wiggle-subsequence/)

```py
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        """
        i-1: 以当前元素结尾且上升的最长wiggle pattern    以当前元素结尾且下降的最长wiggle pattern 
        i:   dp[i-1][1] += 1如果这个数更大             dp[i-1][0] += 1如果这个数更小
        
        """
        dp = [[0, 0] for _ in range(len(nums)) ]
        dp[0][0] = dp[0][1] = 1
        for i in range(1, len(nums)):
            if nums[i] < nums[i - 1]:
                dp[i][1] = max(dp[i - 1][0] + 1, dp[i-1][1])
            elif nums[i] > nums[i - 1]:
                dp[i][0] = max(dp[i-1][0], dp[i - 1][1] + 1)
            else:
                dp[i] = dp[i-1]
                
        return max(dp[-1])
```

[265. Paint House II](https://leetcode.cn/problems/paint-house-ii/)

```py
class Solution:
    def minCostII(self, costs: List[List[int]]) -> int:
        """
        dp[i][j] 第i间房子喷涂j种颜色的目前为止最小代价
        第i房子的颜色只被i-1房子限制
        i-1: j1, j2, j3, ..., jk 
        i- : j1, j2, j3, ..., jk   
        res: max(dp[-1])
        
        dp[i][j] = min(dp[i-1][j'] + cost[i][j]), where j' != j
        """
        
        dp = [[0] * len(costs[0])] * len(costs)
        
        for i in range(len(costs)):
            
            min_color = min(dp[i-1])
            min_idx = dp[i-1].index(min_color)
            sec_min_color = min(dp[i-1][:min_idx] + dp[i-1][min_idx + 1:])
            
            for j in range(len(costs[0])):
                if j != min_idx:
                    dp[i][j] = costs[i][j] + min_color 
                else:
                    dp[i][j] = costs[i][j] + sec_min_color
        
        return min(dp[-1])
```

[1289. Minimum Falling Path Sum II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)

```py
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        """
        和LC265一模一样
        """
        if len(grid[0]) == 1:
            return grid[0][0]
        
        dp = [[0] * len(grid[0])] * len(grid)

        for i in range(len(grid)):
            min_num = min(dp[i - 1])
            min_idx = dp[i - 1].index(min_num)
            sec_min_num = min(dp[i - 1][:min_idx] + dp[i - 1][min_idx + 1:])
            for j in range(len(grid[0])):
                if j != min_idx:
                    dp[i][j] = grid[i][j] + min_num
                else:
                    dp[i][j] = grid[i][j] + sec_min_num
        
        return min(dp[-1])
```

[487. Max Consecutive Ones II](https://leetcode.cn/problems/max-consecutive-ones-ii/)
状态：以当前为结尾且没反转过1；以当前为结尾且反转过1

```py
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        """
        dp: 以i为结尾且没翻转过的最长1  以i为结尾且 翻转过的最长1 
        """
        dp = [[0, 0]] * len(nums)
        res = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                dp[i][0] = 0
                dp[i][1] = dp[i-1][0] + 1
            else:
                dp[i][0] = dp[i-1][0] + 1
                dp[i][1] = dp[i-1][1] + 1

            res = max(res, dp[i][0], dp[i][1])
        
        return res

```

[1186. Maximum Subarray Sum with One Deletion](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/)

```py
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        """
        状态：以当前元素为结尾没有删除过；以当前元素结尾删除过
        """
        dp = [[float("-inf")] * 2 for _ in range(len(arr))]
        
        for i in range(len(arr)):
            dp[i][0] = max(dp[i-1][0] + arr[i], arr[i]) # dp[i][0]是第一种状态：要么加上这个数从上一轮下来，要么从头来
            dp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i]) # dp[i][1]是第二种状态：要么删掉这个数直接就是上一轮的值，要么就从上一轮下来
        
        res = float("-inf")
        for i in range(len(dp)):
            res = max(res, dp[i][0], dp[i][1])
        
        return res
```

## 时间序列加强版

给出一个序列，其中每一个元素可以认为是“一天”，“今天”的状态和之前的“某一天”有关，需要进行挑选

### 模版

1. dp[i]表示第i天的状态，一般和元素i直接相关
2. 千方百计把dp[i]和之前的dp[i']联系起来
3. 最终结果是dp[i]中的某一个

一般两层循环，时间复杂度O(N^2)

### 例题

[1048. Longest String Chain](https://leetcode.cn/problems/longest-string-chain/)

```py
class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        dp = {} # dp[i]: longest str chain ending at words[i]
        words.sort(key = len) # sort based on length
    
        for word in words:
            dp[word] = 1

            for i in range(len(word)): # check for previous words
                prev = word[:i] + word[i + 1:] # all possible previous words

                if prev in dp:
                    dp[word] = max(dp[prev] + 1, dp[word])

        return max(dp.values())
```

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```py
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        """
        dp[i]: 以s[i]为结尾的，最长子序列的长度
        res: max(dp) 最长子序列可能以原列表中的任意一个元素结尾

        Time: O(N^2)
        Space: O(N)
        """
        dp = [1] * len(nums)

        for end in range(len(nums)):
            for i in range(end):
                if nums[i] < nums[end]:  # nums[end]可以接在nums[i]之后
                    dp[end] = max(dp[end], dp[i] + 1)
        
        return max(dp)
```

[673. Number of Longest Increasing Subsequence](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

```py
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        """
        dp[i]: the length of the Longest Increasing Subsequence which ends with nums[i].
        cnt[i]: the number of the Longest Increasing Subsequence which ends with nums[i].
        the res is the sum of each cnt[i] while its corresponding dp[i] is the maximum length
        """
        dp = [1 for _ in range(len(nums))]
        cnt = [1 for _ in range(len(nums))]        
        max_len = res = 0
        
        for i in range(len(nums)):
            for j in range(i):
                if nums[j] < nums[i]:
                    if dp[i] == dp[j] + 1:
                        cnt[i] += cnt[j]
                    if dp[i] < dp[j] + 1:
                        dp[i] = dp[j] + 1
                        cnt[i] = cnt[j]
            if max_len == dp[i]:
                res += cnt[i]
            if max_len < dp[i]:
                res = cnt[i]
                max_len = dp[i]
        
        return res
```

[368. Largest Divisible Subset](https://leetcode.cn/problems/largest-divisible-subset/)

给一个数组，求最大子集，使里面左右元素都能互相整除
dp[i]：在s[:i]中以s[i]结尾的，满足要求的数量
res：max(dp)

[1105. Filling Bookcase Shelves](https://leetcode.cn/problems/filling-bookcase-shelves/)

换种说法：把arr分成若干个subarray，最小化每个subarray最大值之和
状态：dp[i]就是以arr[i]为结尾，分成若干个subarray，最小化每个subarray最大值之和。
第i层有多高：取决于上一层的最后一本书在哪里

[1218. Longest Arithmetic Subsequence of Given Difference](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/)

```py
class Solution:
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        """
        Let dp[i] be the maximum length of a subsequence of the given difference whose last element is i.
        """
        dp = collections.defaultdict(int)
        for num in arr:
            dp[num] = max(dp[num], 1+dp[num-difference])
        return max(dp.values())
```

## 双序列类型

给出2个序列来搞事情
LCS
Shortest Common Supersequence
Edit distance

### 模板

1. dp[i][j]表示针对s[:i]和t[:j]子问题的最优解
2. 千方百计把dp[i][j]往之前的状态转移：dp[i-1][j], dp[i][j-1], dp[i-1][j-1]
3. 最终结果是dp[-1][-1]

### 例题

[1143. Longest Common Subsequence](https://leetcode.cn/problems/longest-common-subsequence/)

```py
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        """
        dp[i][j]就是s[:i]j[:j]的LCS
        """
        dp = [[0] * (len(text2) + 1) for i in range(len(text1) + 1)]
        
        for i in range(len(text1)) :
            for j in range(len(text2)):
                if text1[i] == text2[j]: # 如果相等，就能加一
                    dp[i + 1][j + 1] = dp[i][j] + 1
                else: # 如果不等，就看附近的
                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])
        
        return dp[-1][-1] 

```

[1092. Shortest Common Supersequence](https://leetcode.cn/problems/shortest-common-supersequence/)

```py

```

[72. Edit Distance](https://leetcode.cn/problems/edit-distance/)
dp[i][j] 照抄：s[:i]t[:j]的解

[97. Interleaving String](https://leetcode.cn/problems/interleaving-string/)
dp[i][j] 照抄：s[:i]t[:j]能否交叠组成字符串w[:i+j]

[115. Distinct Subsequences](https://leetcode.cn/problems/distinct-subsequences/)
dp[i][j] 照抄：s[:i]有多少不同的子序列等于t[:j]

[727. Minimum Window Subsequence](https://leetcode.cn/problems/minimum-window-subsequence/)
dp[i][j] 照抄

LCS/SCS变种
LC583
LC712
LC1035
LC1216
最少删除多少个字符能变成回文串
T = S[:-1] 把不相等的删掉LCS
LC1312
一个字符串s最少需要添加多少个字符能变成回文串
T = S[:-1] 找SCS

## 第一类区间类型

给一个序列，要求分割成k个连续区间。要计算这些区间的某个最优性质

### 模板

1. 状态：dp[i][k]表示针对s[:i]分成k个区间，此时能到的最优解
2. 搜寻最后一个区间的起始位置j，将dp[i][k]分割成dp[j-1][k-1]和s[j:i]两部分
3. 最终的结果是dp[-1][k]
注意两个边界条件：dp[0][0], dp[x][0]

### 例题

[1278. Palindrome Partitioning III](https://leetcode.cn/problems/palindrome-partitioning-iii/)
dp[i][k] 最小的字符变动，使得s[:i]能够恰能分成k个字串，且每串都是回文串

[813. Largest Sum of Averages](https://leetcode.cn/problems/largest-sum-of-averages/)

[410. Split Array Largest Sum](https://leetcode.cn/problems/split-array-largest-sum/)

[1335. Minimum Difficulty of a Job Schedule](https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/)

## 第二类区间类型

只给出一个序列S，求一个针对这个序列的最优解
适用条件：无法设计一个dp[i]，使其只与dp[j] j < i有关。但大区间的最优解，可以依赖小区间的最优解

### 模板

1. dp[i][j] 是对s[i:j]的子问题的求解
2. 千方百计将dp[i][j]往小区间dp[i'][j']转移
   - 第一层循环是区间大小，第二层循环是起点
3. 最终结果是dp[i][-1]

### 例题

[516. Longest Palindromic Subsequence](https://leetcode.cn/problems/longest-palindromic-subsequence/)
状态：照抄：dp[i][j] 字符串s[i:j]是回文串的最大subsequence长度

[312. Burst Balloons](https://leetcode.cn/problems/burst-balloons/)
状态：照抄：dp[i][j] 戳爆s[i:j]所有气球，最大化的总得分

[375. Guess Number Higher or Lower II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)

dp[i][j] 最少付多少钱能猜中s[i:j]的数字
结果就是dp[1][-1]

[1246. Palindrome Removal](https://leetcode.cn/problems/palindrome-removal/)
dp[i][j] 对于s[i:j]，每次删除一个回文串，最少多少次删完
结果就是dp[1][-1]
找不到突破口就看最后一个元素

## 一类二类区间合体

[1000. Minimum Cost to Merge Stones](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)
dp[i][j][k] 将区间s[i:j]归并为k堆的最小代价

## 背包类型

给N件物品，每件可用可不用。求某个有上限C的代价实现最大收益

### 模板

dp[i][c] 从前i件物品的子集里选择，代价为c的最大收益。 c = 1...C
dp[i][c] 往dp[i-1][c']上看
最终结果是 max(dp[-1][c]), c = 1...C

特点：
无后效性：在前4件作出的选择，和第5件没有关系：过去不依赖将来，将来不影响过去

### 例题

01经典
dp[i][c] = max(dp[i-1][c], dp[i-1][c-w_i] + v_i)
最终结果 max(dp[-1][c]), c = 1...C

[494. Target Sum](https://leetcode.cn/problems/target-sum/)

dp[i][s] 考虑前i的子集中添加正负号，得到s的方法数量

[1049. Last Stone Weight II](https://leetcode.cn/problems/last-stone-weight-ii/)

[474. Ones and Zeroes](https://leetcode.cn/problems/ones-and-zeroes/)

[879. Profitable Schemes](https://leetcode.cn/problems/profitable-schemes/)

[956. Tallest Billboard](https://leetcode.cn/problems/tallest-billboard/)

# 待分类

[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```py
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        """
        具有最优子结构，子问题相互独立 -> 确定是动态规划问题

        1. 确定base case：amount是0
        2. 确定状态：原问题和子问题的变化的量：目标金额amount
        3. 确定选择：导致状态发生变化的行为
        4. DP数组的定义

        cannot be greedy: choose from the largest to the smallest as the total count is not guaranteed to be smallest
        BF: backtracking using desicion tree
        DP bottom-up:
        DP[i] = min number of coins needed to count to i
        dp[i] = min(1 + dp[i - each_coin])
        dp[amount] is return value

        [1,3,4,5]
        DP[7] = min(1 + DP[6], 1 + DP[4], 1 + DP[3], 1 + DP[2])

        Time: O(amount * len(coins))
        Space: O(amount)
        """
        dp = [float("inf")] * (amount + 1) # go from 0 to amount

        dp[0] = 0 # base case

        for i in range(1, amount + 1): # need to calc dp[amnout], so range(1, amount + 1)
            for c in coins:
                if i - c >= 0:
                    dp[i] = min(dp[i], 1 + dp[i - c])
        
        return dp[amount] if dp[amount] != float("inf") else -1
```

## Grid

This is 2D version of the sequence DP. dp[i][j] means max/min/best value for matrix cell ending at index i, j

### Algo

[62. 不同路径](https://leetcode.cn/problems/unique-paths/)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        """
        number of path to a cell = number of path to its left + to its tops
        dp[r][c] = dp[r - 1][c] + dp[r][c - 1]
        base case: dp[r][c]的第一行和第一列都是1
        最后返回dp[-1][-1]
        """

        dp = [[0 for _ in range(n)] for _ in range(m)]

        for c in range(n):
            dp[0][c] = 1
        for r in rnage(m):
            dp[r][0] = 1
        
        for r in range(1, m):
            for c in range(1, n):
                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]
        
        return dp[-1][-1]
```

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        """
        dp[r][c] = right + down, each one stores the number of unique paths

        Time: O(M*N)
        Space: O(N)
        """
        row = [1] * n
        
        for i in range(m - 1): # wait until first row
            newRow = [1] * n 
            # out of range
            for j in range(n - 2, -1, -1):
                newRow[j] = newRow[j + 1] + row[j]
            row = newRow
        
        return row[0] 
```

[64. Minimum Path Sum](https://leetcode.cn/problems/minimum-path-sum/)

```py
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        """
        dp[r][c] is the minumum path sum to (r, c)
        dp[r][c] = grid[r][c] + min(dp[r-1][c], dp[r][c-1])
        
        Time: O(M*N)
        Space: O(M*N)
        """
        
        rows, cols = len(grid), len(grid[0])
        
        dp = [[0 for _ in range(cols)] for _ in range(rows)]
        
        dp[0][0] = grid[0][0]
        for r in range(1, rows):
            dp[r][0] = grid[r][0] + dp[r-1][0]
        for c in range(1, cols):
            dp[0][c] = grid[0][c] + dp[0][c-1]
            
        for r in range(1, rows):
            for c in range(1, cols):
                dp[r][c] = grid[r][c] + min(dp[r-1][c], dp[r][c-1])
        
        return dp[-1][-1]
```

[221. Maximal Square](https://leetcode.cn/problems/maximal-square/)

## Dynamic number of subproblems

Similar to Sequence DP, except dp[i] depends on a dynamic number of subproblems: dp[i] = max(d[j]) from 0 to i

### Algo

## Partition

This is a continuation of DFS + Memoization problems. The key is to draw the state-space tree and then traverse it

### Algo

## Interval

Find subproblem defined on an interval dp[i][j]

### Algo

## Two sequences

dp[i][j] represents the max/min/best value for the first sequence ending in index i and second sequence ending in index j
可能类似Grid，之后确认

### Algo

## Game theory

This asks for whether a player can win a decision game. Key is to identify winning state, and formulate a winning state as a state that returns a losing state to the opponent

### Algo

## 0-1 Knapsack

### Algo

## Bitmask

Use bitmasks to reduce factorial compelxity to 2^n by encoding the dp state in bitmasks

### Algo

## Other待分类

[509. Fibonacci Number](https://leetcode.cn/problems/fibonacci-number/)

```py
class Solution:
    def fib(self, n: int) -> int:
        """
        Naive recursive algo:
        fib(n):
            if n <= 2:
                f(n) = 1
            else:
                f(n) = fib(n-1) + fib(n-2)
        time: exponential time
        暴力解法存在大量的重叠子问题

        Memoized DP algo
        memo = {}
        fib(n):
            if n in memo:
                return memo[n]
            if n <= 2:
                f(n) = 1
            else:
                f(n) = fib(n-1) + fib(n-2)
            memo[n] = f(n)
            return f(n)


        dp[i] = dp[i-1] + dp[i-2]
        
        Time: O(N)
        Space: O(N)
        """
        if n == 0:
            return 0
        if n == 1:
            return 1
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        
        for i in range(2, n+1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
```

```py
class Solution:
    def fib(self, n: int) -> int:
        """
        只用三个数来代替整个table
        
        时间：O(N)
        空间：O(1)
        """
        if n <= 1:
            return n
        
        cur = 0
        prev1 = 1
        prev2 = 0
        
        for i in range(2, n + 1):
            cur = prev1 + prev2
            prev2 = prev1
            prev1 = cur
        
        return cur
```

[68. Text Justification](https://www.youtube.com/watch?v=ENyox7kNKeY)

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

```py
class Solution:
    def climbStairs(self, n: int) -> int:
        """
        bottom-up DP，从最后往最前面
        站在最后一部，思考如何计算，从而找到递推表达式f(n) = f(n - 1) + f(n - 2)
        """
        if n == 1:
            return 1
        dp = [0] * (n + 1)  # dp[i] is the number of ways to climb to i
        dp[1] = 1  # base case
        dp[2] = 2  # base case
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]  # recurrence relation          
        
        return dp[n]
```

```py
class Solution:
    def climbStairs(self, n: int) -> int:
        """
        可以不把所有的中间结果存下来，只用两个变量来记录

        时间：O(N)
        空间：O(1)
        """
        one = two = 1
        
        for i in range(n - 1):
            tmp = one
            one = one + two
            two = tmp
        
        return one
```

[746. Min Cost Climbing Stairs](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```py
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        """
        Draw a desicion tree for dp problems, the depth of the tree is len(cost), time: O(2^N) -> O(N) with memorization
        Solve problem from right to left, each time add the minimum of a one jump or a two step jump to the dp
        dp[i] += min(dp[i + 1], dp[i + 2])

        Time: O(N)
        Space: O(1) as use only two variables
        """

        # add a 0 to the end
        cost.append(0)

        # [10, 15, 20], 0
        for i in range(len(cost) - 3, -1, -1): # have to start at 15 instead of 20, as there would be out of bound for 20
            cost[i] += min(cost[i + 1], cost[i + 2])

        return min(cost[0], cost[1])

```

[5. Longest Palindromic Substring](https://leetcode.cn/problems/longest-palindromic-substring/)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        """
        find through middle to the beginning and end
        
        Time: O(n^2) : nested loop, each time need O(N), and findPalindrome O(N) times
        Space: O(1)
        """
        res = ""
        
        def findPalindrome(l, r):
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l+1: r] # 多走了一步，所以上一步是满足要求的大小
        
        for i in range(len(s)):
            # odd length
            s1 = findPalindrome(i, i)
            
            # even length
            s2 = findPalindrome(i, i + 1)
            
            if len(s1) > len(res):
                res = s1
            if len(s2) > len(res):
                res = s2
                
        return res
```

[647. Palindromic Substrings](https://leetcode.cn/problems/palindromic-substrings/)

```py
class Solution:
    def countSubstrings(self, s: str) -> int:
        """
        Same as LC5, use a helper() for calc and return the count of Palidrome given the current idx

        Time: O(N^2)
        Space: O(1)
        """
        def countPali(l, r):
            one_res = 0
            while l >= 0 and r < len(s) and s[l] == s[r]:
                one_res += 1
                l -= 1
                r += 1
            return one_res
        
        res = 0
        for i in range(len(s)):
            res += countPali(i, i)
            res += countPali(i, i + 1)
        
        return res       
            
```

[91. Decode Ways](https://leetcode.cn/problems/decode-ways/)

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        """
        BF: when str has more than two digits: draw a desicion tree
        Example: "121" can only branch to 1-26 -> O(2^N)
                 121
             /          \
            1            12
          /   \         /
         2    21       1
        /
        1

        subproblem: once solve 21, the subproblem is 1, solve from right to left
        dp[i] = dp[i + 1] + dp[i + 2]

        Time: O(N)
        Space: O(N), O(1) if only use two variables
        """
        dp = [1] * (len(s) + 1)

        for i in range(len(s) - 1, -1, -1):
            if s[i] == "0":
                dp[i] = 0
            else:
                dp[i] = dp[i + 1]

            if ((i + 1) < len(s)) and ((s[i] == "1") or s[i] == "2" and s[i + 1] in "0123456"): # double digit
            # if 10 <= int(s[i:i+2]) <= 26:
                dp[i] += dp[i + 2]
        
        return dp[0]
```

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        """
        Time: O(N)
        Space: O(N)
        """
        memo = {}
        
        def dfs(idx):
            if idx in memo:
                return memo[idx]
            
            # 走到头了
            if idx == len(s):
                return 1
            
            # 这个string以0开头
            if s[idx] == "0":
                return 0
            
            # 走到前一位：只有1种方式了
            if idx == len(s) - 1:
                return 1
            
            res = dfs(idx + 1)
            if int(s[idx: idx + 2]) <= 26:
                res += dfs(idx + 2)
            
            memo[idx] = res       
                 
            return res
        
        return dfs(0)        
```

[152. Maximum Product Subarray](https://leetcode.cn/problems/maximum-product-subarray/)

```py
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """
        BF: find all the products-> O(N^2)
        DP: 
        all positive: product increasing
        all negative: odd products smaller; even products larger: the sign is alternating
        subproblem is to find the max and min of the previous several elements
        when see 0, reset max and min to 1 to ignore 0

        Time: O(N)
        Space: O(1)
        """
        res = max(nums) # cannot as 0, as the input can be  [-1]
        cur_min, cur_max = 1, 1

        for n in nums:
            if n == 0: # 这个判断也可以不要，因为这样的话下次默认就是cur_max = cur_min = n
                cur_min, cur_max = 1, 1
                continue
            tmp = cur_max * n
            cur_max = max(n * cur_max, n * cur_min, n) # three senarios: [1,2,3], [1,-2,-3], [-1, -2, 3]
            cur_min = min(tmp, n * cur_min, n)
            res = max(cur_max, cur_min, res)
        
        return res
```

index of the maxProduct

```py
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """
        first find the end index, then go from right to left to find the beginning

        Time: O(N)
        Space: O(1)
        """
        cur_min, cur_max = nums[0], nums[0]
        res = nums[0] # cannot be max(nums), as the max(nums) can be result and in this case the index is missed
        end_idx = 0

        # get the end_idx
        for i in range(1, len(nums)): # use i to get the index
            cur = nums[i]
            tmp = cur_max * cur
            cur_max = max(cur_max * cur, cur_min * cur, cur)
            cur_min = max(tmp, cur_min * cur, cur)
            if cur_max > res:
                res = cur_max
                end_idx = i 
        
        # get the begin_idx
        prod = nums[end_idx]
        begin_idx = end_idx - 1
        while prod != res and begin_idx >= 0:
            prod *= nums[begin_idx]
            begin_idx -= 1
        
        print(nums[begin_idx + 1: end_idx + 1])
        return res

```

[139. Word Break](https://leetcode.cn/problems/word-break/)

```py
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        """
        dp[i] means s[i:] whether can be formed by words in wordDict or not

        From right to left
        Time: O(N*M*N), N is len(s), M is len(wordDict)
        Space: O(N+M)
        """
        
        dp = [False] * (len(s) + 1)
        dp[len(s)] = True
        
        for i in range(len(s) - 1, -1, -1):
            for w in wordDict:
                if (i + len(w) <= len(s)) and s[i:i + len(w)] == w:
                    dp[i] = dp[i + len(w)] # at idx i, dp[i] determines at dp[i+len(w)] if s[i:i+len(w)] == w
                if dp[i]:
                    break
        return dp[0]
```

```py
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        """
        DFS + Memo
        
        Time: O(N^3)
        Space: O(N)
        """
        if not s:
            return False
        words = set(wordDict)
        memo = {}
        
        def dfs(s):
            if s in memo:
                return memo[s]
            if not s:
                return True
            for word in words:
                # 前面不同就跳过
                if s[:len(word)] != word:
                    continue
                # 前面相同就可以往后看
                remain = dfs(s[len(word):])
                if remain:
                    memo[s] = True # 保存remain的结果
                    return True
            memo[s] = False
            return False
        
        return dfs(s)
```

[416. Partition Equal Subset Sum](https://leetcode.cn/problems/partition-equal-subset-sum/)

```py
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        """
        for every element, include or not include -> decision tree -> 2^n
        Time: O(N*Sum(nums))
        Space: 
        """

        if sum(nums) % 2 == 1:
            return False
        
        dp = set()
        dp.add(0)
        target = sum(nums) // 2
        for i in range(len(nums) - 1, -1, -1):
            newDP = set()
            for t in dp:
                newDP.add(t + nums[i])
                newDP.add(t)
            dp = newDP
        return True if target in dp else False

```

[121. Best Time to Buy and Sell Stock](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """[买了一次且不持有，买了一次且持有]两个状态"""
        dp = [[0, 0] for _ in range(len(prices))]

        dp[0][0] = 0
        dp[0][1] = -prices[0]
        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  # 买了一次，不持有
            dp[i][1] = max(dp[i-1][1], -prices[i])  # 买了一次，持有
        
        return max(0, dp[-1][0])
```

[122. Best Time to Buy and Sell Stock II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """ [不持有，持有]两种状态，对应的最大收益"""
        dp = [[0, 0] for _ in range(len(prices))]
        dp[0][0] = 0
        dp[0][1] = -prices[0]

        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  # 不持有
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])  # 持有

        return max(0, dp[-1][0])
```

[123. Best Time to Buy and Sell Stock III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

```py
class Solution: 
    def maxProfit(self, prices: List[int]) -> int:
        """
        一共2*2种状态
        """
        dp = [[[0, 0] for _ in range(3)] for _ in range(len(prices))]

        dp[0][1] = dp[0][2] = [0, -prices[0]]

        for i in range(1, len(prices)):
            dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])  # 最多1次买，不持有
            dp[i][1][1] = max(dp[i-1][1][1], -prices[i])  # 最多1次买，持有
            dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])  # 最多2次买，不持有
            dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])  # 最多2次买，持有

        return dp[-1][-1][0]
```

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """
        压缩到O(1)的时间复杂度
        """
        t1_cost = t1_profit = t2_cost = t2_profit = float("-inf")
        for price in prices:
            t1_cost = max(t1_cost, - price)
            t1_profit = max(t1_profit, t1_cost + price)
            t2_cost = max(t2_cost, t1_profit - price)
            t2_profit = max(t2_profit, t2_cost + price)
        
        return max(0, t2_profit)
```

[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) == 1:
            return 0
        n = len(prices)
        dp = [[0, 0] for _ in range(n)]

        # 不持有，持有：两种状态
        dp[0][0] = 0  # 不持有
        dp[0][1] = -prices[0]  # 持有

        dp[1][0] = max(dp[0][0], dp[0][1] + prices[1])  # 不持有
        dp[1][1] = max(dp[0][1], dp[0][0] -prices[1])  # 持有

        for i in range(2, n):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  # 不持有
            dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])  # 持有
        
        return max(0, dp[-1][0])
```

[276. Paint Fence](https://leetcode.cn/problems/paint-fence/)

```py
class Solution:
    def numWays(self, n: int, k: int) -> int:
        """
        dp[i] number of different colors ending at post i
        dp[i] = (k-1)dp[i-1] + (k-1)dp[i-2]
        final res: dp[n]
        """
        if n == 1:
            return k
        if n == 2:
            return k * k
        dp = [0] * (n + 1)
        dp[1] = k
        dp[2] = k * k
        for i in range(3, n + 1):
            dp[i] = (k - 1) * dp[i - 1] + (k - 1) * dp[i - 2]
        
        return dp[n]
        
```

[10. Regular Expression Matching](https://leetcode.cn/problems/regular-expression-matching/)

```py
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        """
        DFS + Memorization
        """
        memo = {} # [(i, j)] whether valid given idx is (i, j)
        def dfs(i, j): # compare s[i] with p[j]
            if (i, j) in memo:
                return memo[(i, j)]
            if i >= len(s) and j >= len(p): # base case
                return True
            if j >= len(p): # when j reaches to the end alone, its definitely not valie
                return False
            # when i >= len(s), and j < len(p), could be True: s="a", p="a*b*"
            
            match = (i < len(s)) and (s[i] == p[j] or p[j] == ".")
            
            if (j + 1) < len(p) and p[j + 1] == "*": # when the next is star
                # 2种方式往后走：用star和不用star
                memo[(i, j)] = (dfs(i, j + 2) or # don't use star
                               (match and dfs(i + 1, j))) # use star: current matches and then check the next one
                return memo[(i, j)]
            
            if match: # 往后走，把后面的结果传递回来
                memo[(i, j)] = dfs(i + 1, j + 1)
                return memo[(i, j)]
            
            # 明确了不能match，直接返回False
            memo[(i, j)] = False
            return False
        
        return dfs(0, 0)
```

```python

        总体思路是从 s[:1] 和 p[:1] 开始判断是否能匹配，每轮添加一个字符并判断是否能匹配，直至添加完整个字符串 s 和 p
        dp[i][j]代表 s[:i] 和 p[:i] 可以匹配

```

# 待分类直通硅谷

## 简介

给定状态S和代价函数cost(S1, S2)，计算min(f(S))的值：以状态为自变量，计算函数的值
**f和cost只与状态S有关** 和如何到达这个状态无关
状态可以是一个整数，一对整数等等

以下是常见的4种状态表示方法

第一题
dp[n]表示s[:n]是否是好的字符串
转移：

1. 从s[n-1]走到s[n]: s[n-1] == 1
2. 从s[n-2]走到s[n]

第二题 用ABCD构造字符串
cost("ABXXXXX") <= cost("CBXXXXX")的话，就不用存"CB"了
-> 对长度相同，最后一个字符串相同的字符串，只存代价最小的
dp[i][j] 0<= j < 4

dp[0] = cost[0]
dp[i][j] = min(dp[i-1][k] + cost[i][j])， k != j
解min(dp[-1])

第三题 lc1444
剩余部分的右下角永远不变：如果横切是给上面，如果竖切是给左边
dp[x][y][z]表示左上角在[x, y]，分成z份的合法方法数
dp[x][y][1] = 1 或0 取决于该披萨有没有苹果

第四题 LC1349
dp[i][j] 表示前i行，分配人的情况为j时的最大人数
dp[0][0] = 1
dp[i][j] = max(dp[i-1][x] + 第j行坐的人数)

一般框架：

1. 定义状态：base case和状态
2. 递推
3. 解是什么

面试时交互的过程，要学会讲清楚

Google常见题目
dp
图：代码相对比较长，考察实现能力，知道怎么做
string, array, sequency：two pointers, sliding windows, prefix sum, 快速求值，单调队列

dry run：把树画出来，把每个值填到节点里
