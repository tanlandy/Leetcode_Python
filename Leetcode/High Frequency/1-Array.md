# Array

# 基础知识，技巧与思路

# 高频题

## 知乎

[27. 移除元素]
[271. 字符串的解码与编码]
[334. 递增的三元子序列]

## Hot100

# 以题型分类

[26. Remove Duplicates from Sorted Array](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        """
        快慢指针，快指针在前面走，当找到一个不同的数的时候，慢指针走一步并更新
        """
        slow = fast = 0
        while fast < len(nums):
            if nums[slow] != nums[fast]:
                slow += 1
                nums[slow] = nums[fast]
            fast += 1

        return slow + 1
```

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow = fast = 0
        while fast < len(nums):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

[271. 字符串的解码与编码](https://leetcode.cn/problems/encode-and-decode-strings/)

组合大文字的时候用数字+特殊字符来连接，decode时候就需要找到数字大小

时间：O(N), N is num of word in words
空间：O(1)

```py
class Codec:
    def encode(self, strs: List[str]) -> str:
        """Encodes a list of strings to a single string.
        """
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res


    def decode(self, s: str) -> List[str]:
        """Decodes a single string to a list of strings.
        """
        res = []
        i = 0

        while i < len(s):
            j = i
            while s[j] != "#":
                j += 1
            length = int(s[i : j])
            res.append(s[j + 1: j + 1 + length])
            i = j + 1 + length

        return res

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(strs))
```

[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

```py
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        """
        keep track of the smallest two numbers in increasing order, and find the last number which will be bigger than the first two. 
        first two smallest numbers can be updated with conditional checks while scanning.
        
        even though the "first" number can be updated to be after the idx of "second" smallest, we can tell that there is a smaller one before the "second" smallest
        """
        
        first = second = float("inf")
        
        for n in nums:
            if n <= first:
                first = n
            elif n <= second:
                second = n
            else: # n > first and n > second
                return True
        
        return False
```

## 经典

[189. Rotate Array](https://leetcode.cn/problems/rotate-array/)
Given an array, rotate the array to the right by k steps, where k is non-negative.

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Place every element of the array at its correct position

        Time: O(N)
        Space: O(N)
        """
        n = len(nums)
        a = [0] * n
        
        for i in range(n):
            a[(i + k) % n] = nums[i]
        
        nums[:] = a
```

```py
class Solution:
    def rotate(self, nums, k) -> None:
        """
        reverse three times: reverse all + reverse first k + reverse last n-k

        n = 7, k = 3
        Original List                   : 1 2 3 4 5 6 7
        After reversing all numbers     : 7 6 5 4 3 2 1
        After reversing first k numbers : 5 6 7 4 3 2 1
        After revering last n-k numbers : 5 6 7 1 2 3 4 --> Result

        Time: O(N)
        Space: O(1)
        """
        k %= len(nums)
        self.reverse(nums, 0, len(nums)-1)
        self.reverse(nums, 0, k-1)
        self.reverse(nums, k, len(nums)-1)

    def reverse(self, nums, start, end) -> None:
        while start < end: 
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1
```

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Cyclic Replacement
        
        Time: O(N)
        Space: O(1)
        """
        n = len(nums)
        k %= n
        
        start = count = 0
        while count < n:
            current, prev = start, nums[start]
            while True:
                next_idx = (current + k) % n
                nums[next_idx], prev = prev, nums[next_idx]
                current = next_idx
                count += 1
                
                if start == current:
                    break
            start += 1
```

Look-and-Say Sequence
1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211
the next number is generated by the count and the digit in previous one
1: one 1 -> 11
11: two 1s -> 21
21: one 2 one 1 -> 1211

```py
def next_number(s):
    result = []
    i = 0
    while i < len(s):
        count = 1
        while i + 1 < len(s) and s[i] == s[i+1]: # count the number of the digit
            i += 1
            count += 1
        result.append(str(count) + s[i])
        i += 1
    return ''.join(result)

# generate first 4 numbers
s = "1"
print(s)
n = 4
for i in range(n-1):
    s = next_number(s)
    print(s)
```

ord() returns an integer which represents the Unicode code point of the Unicode character passed into the function.

```py
print(ord('A')) # 65
print(ord('B')) # 66
print(ord('Z')) # 90

# to make A represent 1, B represent 2, etc...
print(ord('A') - ord('A') + 1)
print(ord('B') - ord('A') + 1)
print(ord('C') - ord('A') + 1)
print(ord('Z') - ord('A') + 1)
```

Spreadsheet Encoding
convert the column IDs in a spreadsheet into an integer
"AA” equals 27 because it represents the 27th column.

```py
def spreadsheet_encode_column(col_str):
    num = 0
    count = len(col_str)-1 # determine the power of the base
    for s in col_str:
        num += 26 ** count * (ord(s) - ord('A') + 1)
        count -= 1
    return num

print(spreadsheet_encode_column("ZZ"))
```

check if two strings are anagrams

```py
def is_anagram(s1, s2):
    ht = dict()

    if len(s1) != len(s2):
        return False

    for i in s1:
        if i in ht:
            ht[i] += 1
        else:
            ht[i] = 1
    for i in s2:
        if i in ht:
            ht[i] -= 1
        else:
            ht[i] = 1

    # check the value of in the ht is 0 or not
    for i in ht:
        if ht[i] != 0:
            return False
    return True

s1 = "fairy tales"
s2 = "rail safety"
## normalizing the strings
s1 = s1.replace(" ", "").lower()
s2 = s2.replace(" ", "").lower()

print(is_anagram(s1, s2))
```

Is palindrome permutation
at most 1 odd count of a charater

```py
def is_palin_perm(input_str):
    input_str = input_str.replace(" ", "")
    input_str = input_str.lower()

    d = dict()

    for i in input_str:
        if i in d:
            d[i] += 1
        else:
            d[i] = 1

    odd_count = 0
    for k, v in d.items():
        if v % 2 != 0 and odd_count == 0:
            odd_count += 1
        elif v % 2 != 0 and odd_count != 0:
            return False
    return True

palin_perm = "Tact Coa"
not_palin_perm = "This is not a palindrome permutation"

print(is_palin_perm(palin_perm))
print(is_palin_perm(not_palin_perm))
```

Integer to String
use chr(ord('0')) = chr(48) = '0'
chr(ord('0') + 1) = chr(48 + 1) = chr(49) = '1'
chr(ord('0') + 2) = chr(48 + 2) = chr(50) = '2'

```py
def int_to_str(input_int):
    
    if input_int < 0:
        is_negative = True
        input_int *= -1
    else:
        is_negative = False

    output_str = []

    if input_int == 0:
        output_str.append('0')
    else:   
        while input_int > 0:
            output_str.append(chr(ord('0') + input_int % 10)) # last digit was extracted by %
            input_int //= 10
        output_str = output_str[::-1]

    output_str = ''.join(output_str)

    if is_negative:
        return '-' + output_str
    else:
        return output_str

input_int = 123
print(input_int)
print(type(input_int))

output_str = int_to_str(input_int)
print(output_str)
print(type(output_str))
```

[8. String to Integer (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)

用sign, res, idx，idx一直往后走，先删除空格，然后记录正负号， 最后处理数字，每次数字检查是否越界，否则res = 10*res + curDigit；越界的条件>INT_MAX // 10，或者== INT_MAX同时curDit>INT_MAX % 10，越界了就返回最大值或者最小值；最大值pow(2, 31)-1；最小值-pow(2, 31)

时间：O(n)
空间：O(1)

```python
class Solution:
    def myAtoi(self, s: str) -> int:
        sign = 1
        res = 0
        idx = 0
        n = len(s)
        
        INT_MAX = pow(2, 31) - 1
        INT_MIN = -pow(2, 31)
        
        # 先删除空格
        while idx < n and s[idx] == " ":
            idx += 1
        
        # 判断正负号
        if idx < n and s[idx] == "+":
            sign = 1
            idx += 1
        elif idx < n and s[idx] == "-":
            sign = -1
            idx += 1
    
        # 接下来都是数字
        while idx < n and s[idx].isdigit():
            digit = int(s[idx])
            # 检查过大或过小：如果过大或过小，就返回最大值或最小值
            # 1. res > Integer.MAX_VALUE / 10肯定会在下一个超过
            # 2. res < Integer.MAX_VALUE / 10就不用担心
            # 3. res == Integer.MAX_VALUE / 10，只有0-7可以满足，因为Integer.MAX_VALUE % 10 = 7
            if (res > INT_MAX // 10) or (res == INT_MAX // 10 and digit > INT_MAX % 10):
                return INT_MAX if sign == 1 else INT_MIN
            res = 10 * res + digit
            idx += 1
        return sign * res
```

[976. Largest Perimeter Triangle](https://leetcode.cn/problems/largest-perimeter-triangle/)

```py
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort(reverse = True)
        
        for i in range(len(nums) - 2):
            if nums[i] < nums[i + 1] + nums[i + 2]:
                return nums[i] + nums[i + 1] + nums[i + 2]
            else:
                i += 1
        
        return 0
```

[13. Roman to Integer](https://leetcode.cn/problems/roman-to-integer/)

```py
class Solution:
    def romanToInt(self, s: str) -> int:
        sym_val = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000, "IV": 4, "IX": 9, "XL": 40, "XC": 90, "CD": 400, "CM": 900}
        
        res = 0
        i = 0
        while i < len(s):
            if i < len(s) - 1 and s[i: i + 2] in sym_val: # 要注意i的取值范围
                res += sym_val[s[i:i + 2]]
                i += 2
            else:
                res += sym_val[s[i]]
                i += 1
        return res
```

[12. Integer to Roman](https://leetcode.cn/problems/integer-to-roman/)

```py
class Solution:
    def intToRoman(self, num: int) -> str:
        digits = [(1000, "M"), (900, "CM"), (500, "D"), (400, "CD"), (100, "C"), 
                  (90, "XC"), (50, "L"), (40, "XL"), (10, "X"), (9, "IX"), 
                  (5, "V"), (4, "IV"), (1, "I")] # 从大到小排序
        
        res = []
        
        for val, symbol in digits:
            if num == 0:
                break
            
            count, num = divmod(num, val) # 计算出商和余数
            res.append(symbol * count)
        
        return "".join(res)
```

## Time类型

Time convertion: Given a time in -hour AM/PM format, convert it to military (24-hour) time.

```py
def timeConversion(s):
    """
    注意字符串的使用
    """
    if s[0:2] == "12":
        if s[-2:] == "AM":
            return "00" + s[2:-2]
        else:
            return s[:-2]
    else:
        if s[-2:] == "AM":
            return s[:-2]
        else:
            return str(int(s[:2]) + 12) + s[2:-2]
```

[2224. Minimum Number of Operations to Convert Time](https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/)

```py
class Solution:
    def convertTime(self, current: str, correct: str) -> int:
        # current and target time in mins
        current_time = 60 * int(current[0:2]) + int(current[3:5]) 
        target_time = 60 * int(correct[0:2]) + int(correct[3:5])

        # diff in mins
        diff = target_time - current_time

        # Greedy approach
        count = 0 
        for i in [60, 15, 5, 1]:
            count += diff // i # add number of operations needed with i to count
            diff %= i # Diff becomes modulo of diff with i
        return count
```

[12进制时间转换为24进制]
input: "07:05:45PM"
output: "19:05:45"

```py
def timeConversion(s):
    """
    分别根据"AM"和"PM"这两种情况来考虑，注意PM时候转换的技巧
    """
    if s[-2:] == "AM":
        if s[0:2] == "12":
            return "00" + s[2:-2]
        else:
            return str(s[:-2])

    elif s[-2:] == "PM":
        if s[0:2] == "12":
            return str(s[:-2])
        else:
            return str(int(s[0:2]) + 12) + s[2:-2]
```

[681. Next Closest Time](https://leetcode.cn/problems/next-closest-time/)

```py
class Solution(object):
    def nextClosestTime(self, time):
        """
        Generate all possible 2 digit values, then check minute and hour
        
        for 19:34 as input
        we get twoDigits array as
        ['11', '13', '14', '19', '31', '33', '34', '39', '41', '43', '44', '49', '91', '93', '94', '99']

        Time: O(1)
        Space: O(1)
        """
        hour, minute = time.split(":")
        
        # Generate all possible 2 digit values
        # There are at most 16 sorted values here
        nums = sorted(set(hour + minute))
        two_digit_values = [a+b for a in nums for b in nums]

        # Check if the next valid minute is within the hour
        i = two_digit_values.index(minute)
        if i + 1 < len(two_digit_values) and two_digit_values[i+1] < "60":
            return hour + ":" + two_digit_values[i+1]

        # Check if the next valid hour is within the day
        i = two_digit_values.index(hour)
        if i + 1 < len(two_digit_values) and two_digit_values[i+1] < "24":
            return two_digit_values[i+1] + ":" + two_digit_values[0]
        
        # Return the earliest time of the next day
        return two_digit_values[0] + ":" + two_digit_values[0]
```

[14. Longest Common Prefix](https://leetcode.cn/problems/longest-common-prefix/)
先找到最短的字符串，然后依次和其他比较，比较时候发现不相同就返回那个长度，最后返回最短的字符串（只有一个字符串的情况）；本题要点是min(strs, key = len)的使用方法

时间：O(N*S)
空间：O(min(len(s)))

```py
class Solution:
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        if not strs:
            return ""

        shortest = min(strs, key = len)

        for idx, c in enumerate(shortest):
            for other in strs:
                if other[idx] != c:
                    return shortest[:idx]

        return shortest
```

[171. Excel Sheet Column Number](https://leetcode.cn/problems/excel-sheet-column-number/)
学会使用ord("A")，以及递归的思路

```py
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        res = 0

        for c in columnTitle:
            res = res * 26
            res += (ord(c) - ord("A") + 1)

        return res
```

[1047. Remove All Adjacent Duplicates In String](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

```py
class Solution:
    def removeDuplicates(self, s: str) -> str:
        """
        用stack，每次遇到新的就比较一下是否和top相同，相同就弹栈，不同就加进来
        """
        stack = []

        for c in s:
            if stack and c == stack[-1]:
                stack.pop()
            else:
                stack.append(c)

        return "".join(stack)
```

[1209. Remove All Adjacent Duplicates in String II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)

```py
class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        """
        用stack同时存这个char和出现的次数，一旦出先次数达到k就pop，最后decode到需要的大小
        """
        stack = [["#", 0]]

        for c in s:
            if stack[-1][0] == c:
                stack[-1][1] += 1
                if stack[-1][1] == k:
                    stack.pop()
            else:
                stack.append([c, 1])

        return "".join(c * n for c, n in stack)
```

[5. Longest Palindromic Substring](https://leetcode.cn/problems/longest-palindromic-substring/)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        """
        从头到尾，依次遍历可能的回文字符，每次遍历之后都更新潜在的最大值
        """
        res = ""

        def findPalindrome(l, r):
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1 # 从中间往两边走
                r += 1
            return s[l + 1: r] # 多走了一步，所以要返回之前的一步

        for i in range(len(s)):
            # odd length
            s1 = findPalindrome(i, i)

            # even length
            s2 = findPalindrome(i, i + 1)

            if len(s1) > len(s):
                res = s1
            if len(s2) > len(s):
                res = s2

        return res
```

[1332. Remove Palindromic Subsequences](https://leetcode.cn/problems/remove-palindromic-subsequences/)

```py
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        """
        Asked for subsequency instead of substring
        """
        if not s:
            return 0
        
        if s == s[::-1]:
            return 1
        
        return 2
```

[2239. Find Closest Number to Zero](https://leetcode.cn/problems/find-closest-number-to-zero/)

```py
class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        """
        make (-abs(a), a) tuples, get the maxmium -abs(a), return the second index
        """
        return max([(-abs(a), a) for a in nums])[1]
```

[1362. Closest Divisors](https://leetcode.cn/problems/closest-divisors/)

```py
class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        """
        Greedy check from sqrt(x+2) to 1, if can be divided by that number, then return 
        
        Time: O(sqrt(num))
        Space: O(1)
        """
        for n in range(int((num + 2) ** 0.5), 0, -1):
            if (num + 1) % n == 0:
                return [n, (num + 1) // n]
            if (num + 2) % n == 0:
                return [n, (num + 2) // n]
```

[287. Find the Duplicate Number](https://leetcode.cn/problems/find-the-duplicate-number/)

[41. First Missing Positive](https://leetcode.cn/problems/first-missing-positive/)

<https://leetcode.cn/problems/longest-palindromic-substring/discuss/2030458/Python>

[1354. Construct Target Array With Multiple Sums](https://leetcode.cn/problems/construct-target-array-with-multiple-sums/)

```py
class Solution:
    def isPossible(self, A: List[int]) -> bool:
        """
        Subtract the largest with the rest of the array, and put the new element into the array. Repeat until all elements become one
        use mod to quickly achieve target value, as the cur_max needs to be substracted repeatly until becomes smaller than cur_sum
        
        Space: O(N + logK * logN)
        Time: O(N)
        """
        cur_sum = sum(A)
        A = [-a for a in A]
        heapq.heapify(A)
        while True:
            a = -heapq.heappop(A)
            cur_sum -= a
            if a == 1 or cur_sum == 1:
                return True
            if a < cur_sum or cur_sum < 1 or a % cur_sum == 0:
                return False
            a %= cur_sum
            cur_sum += a
            heapq.heappush(A, -a)
```

[665. Non-decreasing Array](https://leetcode.cn/problems/non-decreasing-array/)

```py
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        """
        重点是找到不合理的数字之后，如何赋值变得合理
        
        Time: O(N)
        Space: O(1)
        """
        decrease = False
        
        for i in range(1, len(nums)):
            if nums[i - 1] > nums[i]:
                if decrease:
                    return False
                decrease = True
                
                if i < 2 or nums[i - 2] <= nums[i]: # [4,7,5]
                    nums[i - 1] = nums[i]
                else:  
                    nums[i] = nums[i - 1]  # [4, 5, 3]
        
        return True
```

```py
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        """
        without modifing input array
        """
        idx = -1
        
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                if idx != -1:
                    return False
                idx = i
        
        # return True if we can remove this element and have A[p-1] <= A[p+1] or remove next element and have A[p] <= A[p+2].
        return idx in [-1, 0, len(nums) - 2] or nums[idx - 1] <= nums[idx + 1] or nums[idx] <= nums[idx + 2]
```

[1010. Pairs of Songs With Total Durations Divisible by 60](https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/)

```py
class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        """
        similar to twoSum: record the frequencies of each remainder
        
        Time: O(N)
        Space: O(1)
        """
        # remainders = collections.defaultdict(int)
        remainders = [0] * 60 
        res = 0
        for t in time:
            if t % 60 == 0:
                res += remainders[0]
            else:
                res += remainders[60 - t % 60]
            remainders[t % 60] += 1
        
        return res
```

[1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/)

```py
class Solution:
    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
        """
        find the maximum height and width, then calculate
        step: sort, iteratethe inputs
        edge case: height at edges
        """
        horizontalCuts.sort()
        verticalCuts.sort()
        
        max_h = max(horizontalCuts[0], h - horizontalCuts[-1])
        for i in range(1, len(horizontalCuts)):
            max_h = max(max_h, horizontalCuts[i] - horizontalCuts[i - 1])
            
        max_w = max(verticalCuts[0], w - verticalCuts[-1])
        for i in range(1, len(verticalCuts)):
            max_w = max(max_w, verticalCuts[i] - verticalCuts[i - 1])
        
        return max_h * max_w % (10 ** 9 + 7)
```

[376. Wiggle Subsequence](https://leetcode.cn/problems/wiggle-subsequence/)
有些类似于LC121

```py
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        """
        greedy如果上升就一直上升，然后再拐点
        用pre_diff来记录是一直上升还是一直下降
        """
        if len(nums) < 2:
            return len(nums)
        pre_diff = nums[1] - nums[0]
        count = 2 if pre_diff != 0 else 1
        
        for i in range(2, len(nums)):
            diff = nums[i] - nums[i - 1]
            if (diff > 0 and pre_diff <= 0) or (diff < 0 and pre_diff >= 0):
                count += 1
                pre_diff = diff
        
        return count
```

## String

[1323. Maximum 69 Number](https://leetcode.cn/problems/maximum-69-number/description/)

```py
class Solution:
    def maximum69Number (self, num: int) -> int:
        """
        输入的是digit，digit转换为list of string: s = list(str(num))
        """
        s = list(str(num))
        for idx, ch in enumerate(s):
            if ch == "6":
                s[idx] = "9"
                return "".join(s)
        
        return num
```

[1592. Rearrange Spaces Between Words](https://leetcode.cn/problems/rearrange-spaces-between-words/)

```py
class Solution:
    def reorderSpaces(self, text: str) -> str:
        words = text.split()
        cnt = len(words)
        spaces = text.count(' ')
        gap = 0 if cnt == 1 else spaces // (cnt - 1)
        trailing_spaces = spaces - gap * (cnt - 1) 
        return (' ' * gap).join(words) + ' ' * trailing_spaces   
```

[929. Unique Email Addresses](https://leetcode.cn/problems/unique-email-addresses/)

```py
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        uniqueEmails = set()
        
        for email in emails:
            name, domain = email.split("@") # 先按照@分开
            local = name.split("+")[0].replace(".", "") # 然后按照+分开的同时，把“，”替换成“”（删除）
            uniqueEmails.add(local + "@" + domain) # 最后合并起来，添加到set里面
        
        return len(uniqueEmails)
```

[243. Shortest Word Distance](https://leetcode.cn/problems/shortest-word-distance/)

```py
class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        """
        走一遍，用一个指针分别指向l, r，每当遇到了单词就存下来位置，当都第一次遇到之后就可以计算
        Time: O(N)
        Space: O(1)
        """
        l = r = -1
        res = len(wordsDict)
        
        for i in range(len(wordsDict)):
            if wordsDict[i] == word1:
                l = i
            elif wordsDict[i] == word2:
                r = i
            
            if (l != -1 and r != -1):
                res = min(res, abs(l - r))
        
        return res
```

[244. Shortest Word Distance II](https://leetcode.cn/problems/shortest-word-distance-ii/)

```py
class WordDistance:
    """
    word_idx = {word: [idx]}
    when call shortest(), find the shortest in two idx(sorted array), use two pointers
    """

    def __init__(self, wordsDict: List[str]):
        self.word_idx = collections.defaultdict(list)
        for idx, w in enumerate(wordsDict):
            self.word_idx[w].append(idx)
    
    def shortest(self, word1: str, word2: str) -> int:
        idxs1, idxs2 = self.word_idx[word1], self.word_idx[word2]
        l = r = 0
        min_diff = float("inf")
        
        while l < len(idxs1) and r < len(idxs2):
            min_diff = min(min_diff, abs(idxs1[l] - idxs2[r]))
            if idxs1[l] < idxs2[r]:
                l += 1
            else:
                r += 1
        
        return min_diff

```

[339. Nested List Weight Sum](https://leetcode.cn/problems/nested-list-weight-sum/)

```python
class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        """
        用dfs，如果是数字就total +=，如果不是就深度加一继续。
        因为每次需要nestedList和depth，所以dfs()的参数有这两个

        时间：O(N), N is size of nestedList
        空间：O(K), K is largest List
        """
        def dfs(nestedList, depth):
            total = 0
            for nested in nestedList:
                if nested.isInteger():
                    total += nested.getInteger() * depth
                else:
                    total += dfs(nested.getList(), depth + 1)
            return total
        return dfs(nestedList, 1)
```

```py

class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        queue = collections.deque(nestedList)
        depth = 1
        total = 0
        
        while queue:
            for _ in range(len(queue)):
                item = queue.popleft()
                if item.isInteger():
                    total += item.getInteger() * depth
                else:
                    for elem in item.getList():
                        queue.append(elem)
            
            depth += 1
        
        return total
```

[364. Nested List Weight Sum II](https://leetcode.cn/problems/nested-list-weight-sum-ii/)

```py
class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:
        """
        先找到maxDepth，然后逐个计算
        """
        maxDepth = self.findMaxDepth(nestedList)
        return self.weightedSum(nestedList, 1, maxDepth)
    
    def findMaxDepth(self, nestedList):
        maxDepth = 1
        
        for item in nestedList:
            if not item.isInteger() and item.getList():
                maxDepth = max(maxDepth, 1 + self.findMaxDepth(item.getList()))    
        return maxDepth
    
    def weightedSum(self, nestedList, depth, maxDepth):
        total = 0
        
        for item in nestedList:
            if item.isInteger():
                total += item.getInteger() * (maxDepth + 1 - depth)
            else:
                total += self.weightedSum(item.getList(), depth + 1, maxDepth)
        
        return total
```

```py
class Solution:
    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:
        """
        [1, [4, [6]]]

        res += 1
        res += 1 + 4
        res += 1 + 4 + 6
        use level_sum to store the previous cumulative sum, add those to res multiple times depending on the level

        Time: O(N), N is len(nestedList)
        Space: O(N)
        """
        queue = collections.deque(nestedList)
        res = 0
        level_sum = 0
        
        while queue:
            for _ in range(len(queue)):
                item = queue.popleft()                
                if item.isInteger():
                    level_sum += item.getInteger()
                else:
                    for elem in item.getList():
                        queue.append(elem)
            res += level_sum
        return res
```

[792. Number of Matching Subsequences](https://leetcode.cn/problems/number-of-matching-subsequences/)

```py
class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        """
        把每个word都比较一遍，看是不是s的subsequence
        因为可能words中有重复，就用一个map来存已经比对过的结果
        
        每次比对：
        stack存这个word，然后从后往前遍历s，遇到相同的就pop，最后stack空了就说明都呼应上了
        
        """
        def issubseq(s,t):
            stack = []
            for i in t:
                stack.append(i)
            
            n = len(s)
            for i in range(n-1,-1,-1):
                if not stack:
                    return True
                if stack[-1] == s[i]:
                    stack.pop()
            return stack == []
        
        
        hashmap = {}
        
        count = 0
        for word in words:
            if word not in hashmap:
                if issubseq(s,word):
                    count += 1
                    hashmap[word] = True
                else:
                    hashmap[word] = False
            else:
                if hashmap[word]:
                    count += 1
        return count
```

```py
class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        """
        store the first letter of word in dict
        """
        ch_word = collections.defaultdict(list)
        
        # words = ["a","bb","acd","ace"]
        # ch_word: {a:["a", "acd", "ace"], b:["bb"]}
        for word in words:
            ch_word[word[0]].append(word)
        
        count = 0
        
        # s = "abcde"
        for ch in s:
            word_remains = ch_word[ch]
            del ch_word[ch] # 要删掉，否则会重复计算。比如s="aa", words = ["a"]
            for word in word_remains:
                if len(word) == 1:
                    count += 1
                else: # {c: "cd", c:"ce"}
                    ch_word[word[1]].append(word[1:])
        
        return count
```

[1554. Strings Differ by One Character](https://leetcode.cn/problems/strings-differ-by-one-character/)

```py
class Solution:
    def differByOne(self, dict: List[str]) -> bool:
        # only need one pass to solve the problem using hashset:
        seens = set()
        for word in dict:
            for i, c in enumerate(word):
       # change 'abcd' into the form of '.bcd', 'a.cd' ...
                masked_word = word[:i] + '.' + word[i+1:]
                if masked_word in seens:
                    return True
                else:
                    seens.add(masked_word)
        return False
```

[777. Swap Adjacent in LR String](https://leetcode.cn/problems/swap-adjacent-in-lr-string/)

```py
class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        """
        同LC2337

        分别找start和end里所有的L和R，然后一一比较start和end里的L，start的L不能在end的L的左边
        """
        
        # 先判断里面的L和R的数量是否相等
        if start.replace("X", "") != end.replace("X", ""):
            return False
        
        startL = [i for i in range(len(start)) if start[i] == "L"]
        endL = [i for i in range(len(end)) if end[i] == "L"]        
        startR = [i for i in range(len(start)) if start[i] == "R"]        
        endR = [i for i in range(len(end)) if end[i] == "R"]        
        
        for i, j in zip(startL, endL):
            if i < j:
                return False
        
        for i, j in zip(startR, endR):
            if i > j:
                return False
        
        return True
```

[394. Decode String](https://leetcode.cn/problems/decode-string/)

```py
class Solution:
    def decodeString(self, s: str) -> str:
        """
        When we hit an open bracket, we know we have parsed k for the contents of the bracket, so 
        push (current_string, k) to the stack, so we can pop them on closing bracket to duplicate
        the enclosed string k times.
        """
        stack = []
        res = ""
        k = 0

        for char in s:
            if char == "[":
                # Just finished parsing this k, save current string and k for when we pop
                stack.append((res, k))
                # Reset current_string and k for this new frame
                res = ""  # res一旦遇到[就全新开始
                k = 0
            elif char == "]":
                # We have completed this frame, get the last current_string and k from when the frame 
                last_string, last_k = stack.pop(-1)
                res = last_string + last_k * res
            elif char.isdigit():
                k = k * 10 + int(char)
            else:
                res += char

        return res
```

[541. Reverse String II](https://leetcode.cn/problems/reverse-string-ii/)

```py
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        slist = list(s)
        
        for i in range(0, len(s), 2 * k):
            l = i
            r = min(i + k - 1, len(s) - 1) # 要注意的点
            while l < r:
                slist[l], slist[r] = slist[r], slist[l]
                l += 1
                r -= 1
        
        return "".join(slist)
```

[557. Reverse Words in a String III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        last = -1
        slist = list(s)
        for i in range(len(s) + 1):
            if i == len(s) or slist[i] == " ": # 走到了空格，即word的后一位
                l = last + 1 # l是上一个空格+1
                r = i - 1 # r是空格-1
                while l < r:
                    slist[l], slist[r] = slist[r], slist[l]
                    l += 1
                    r -= 1
                last = i # last是空格
        
        return "".join(slist)
```

[821. Shortest Distance to a Character](https://leetcode.cn/problems/shortest-distance-to-a-character/)

```py
class Solution(object):
    def shortestToChar(self, S, C):
            n = len(S)
            res = [n] * n
            pos = -n
            for i in list(range(n)) + list(range(n)[::-1]):
                if(S[i] == C):  pos = i
                res[i] = min(res[i], abs(i - pos))
            return res  
```

[838. Push Dominoes](https://leetcode.cn/problems/push-dominoes/)

```py
class Solution(object):
    def pushDominoes(self, dominoes):
        """
        :type dominoes: str
        :rtype: str
        """
        lst = list(dominoes)
        dist = [0] * len(dominoes)
        rDist = None
        for i, val in enumerate(lst):
            if val == 'R':
                rDist = 0
            elif val == 'L':
                rDist = None
            elif rDist != None:
                rDist += 1
                dist[i] = rDist
                lst[i] = 'R'
        lDist = None
        for i in range(len(lst) - 1, -1, -1):
            if dominoes[i] == 'L':
                lDist = 0
            elif dominoes[i] == 'R':
                lDist = None
            elif lDist != None:
                lDist += 1
                if lDist < dist[i] or lst[i] == '.':
                    lst[i] = 'L'
                elif lDist == dist[i]:
                    lst[i] = '.'
        return ''.join(lst)
```

[1328. Break a Palindrome](https://leetcode.cn/problems/break-a-palindrome/)

```py
class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        s = list(palindrome)
        if len(s) <= 1:
            return ""
        for idx, ch in enumerate(s):
            if idx > len(s) // 2 - 1: # there's only "a" in the input
                s[-1] = "b"
                return "".join(s)
            if ch != "a": # change the first non-"a" element to "a"
                s[idx] = "a"
                return "".join(s)
```

[Caesar Cipher]
string s is rotated by k

```py
def caesarCipher(s, k):
    k %= 26
    s = list(s)
    for idx, ch in enumerate(s):
        # ord("a") = 97, chr(97) = "a"
        # ord("A") = 65
        if ord("a") <= ord(ch) <= ord("z"):
            pos = ord(ch) + k
            if pos > ord("z"):
                pos -= 26
            s[idx] = chr(pos)
        elif ord("A") <= ord(ch) <= ord("Z"):
            pos = ord(ch) + k
            if pos > ord("Z"):
                pos -= 26
            s[idx] = chr(pos)
    
    return "".join(s)
```

[1662. Check If Two String Arrays are Equivalent](https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/)

```py
class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        p1 = p2 = 0
        w1 = w2 = 0
        
        while w1 < len(word1) and w2 < len(word2):
            if word1[w1][p1] != word2[w2][p2]:
                return False
            p1 += 1 # 重点：移动pointer的时机在比较length之前，用"a"来举例就知道了
            p2 += 1
            if p1 == len(word1[w1]):
                p1 = 0
                w1 += 1
            if p2 == len(word2[w2]):
                p2 = 0
                w2 += 1

        
        return w1 == len(word1) and w2 == len(word2)
```

[899. Orderly Queue](https://leetcode.cn/problems/orderly-queue/description/)

```py
class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        """
        if k == 1: can only be rorated 
        if k > 1: can be formed to any permutations, return the smallest
        """
        if k == 1:
            return min(s[i:] + s[:i] for i in range(len(s)))
        else:
            return "".join(sorted(s))
```

### Prefix类型

[Prefix](15-Prefix.md)

### Palindrome类型

[125. Valid Palindrome](https://leetcode.cn/problems/valid-palindrome/)

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = s.lower()
        
        l, r = 0, len(s) - 1
        while l < r:
            while l < r and not s[l].isalnum():
                l += 1
            while l < r and not s[r].isalnum():
                r -= 1
            if s[l] != s[r]:
                return False
            l += 1
            r -= 1
        
        return True
```

[680. Valid Palindrome II](https://leetcode.cn/problems/valid-palindrome-ii/)

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def check_pad(l, r):
            while l < r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True
        
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] != s[r]:
                return check_pad(l, r - 1) or check_pad(l + 1, r)
            l += 1
            r -= 1
        
        return True
```

palindrome index:
determine the index of a character that can be removed to make the string a palindrome

anagram:
split into two substrings. determine the minimum number of characters to change to make the two substrings into anagrams of one another

### 纯代码

[68. Text Justification](https://leetcode.cn/problems/text-justification/)

```py
class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        """
        1, how many words in each line
        2, how many space btw each word
        """
        
        n = len(words)
        L = maxWidth

        i = 0 # index of current word
        
        # return # of words in a line
        def getWords(i):
            k = 0
            l = " ".join(words[i:i+k])
            while len(l) <= L and i + k <= n:
                k += 1
                l = " ".join(words[i:i+k])
            k -= 1 # 最后总是多走了一步
            return k # k words in a line
        
        # insert space btw words in a line
        def insertSpace(i, k):
            """
            reconstruct k words in a line
            """
            l = " ".join(words[i:i+k])
            
            if k == 1 or i + k == n: # if only one word, or is the last line
                spaces = L - len(l)
                line = l + " " * spaces
            else:
                spaces = L - len(l) + (k - 1) # total number of spaces we have in a line: total_length - words_length + (k-1) spaces btw k words
                space = spaces // (k - 1) # # of space btw words in this line
                left = spaces % (k - 1) # if odd, # of left words
                
                if left > 0:
                    line = (" " * (space + 1)).join(words[i:i + left]) # left words
                    line += " " * (space + 1)
                    line += (" " * space).join(words[i+left: i+k]) # right words
                else:
                    line = (" " * space).join(words[i: i+k])
            return line
        
        res = []
        while i < n:
            k = getWords(i)
            res.append(insertSpace(i, k))
            i += k
        
        return res
```

[65. Valid Number](https://leetcode.cn/problems/valid-number/description/)

```python
class Solution:
    def isNumber(self, s: str) -> bool:
        """
        1. sign: only first, or right after "eE"
        2. expo: before and after seenDigit, only appear once
        3. dot: no expo before, only appear once
        """
        
        seen_digit = seen_expo = seen_dot = False
        
        for i, ch in enumerate(s):
            if ch.isdigit():
                seen_digit = True
            elif ch in "+-":
                if i > 0 and s[i - 1] != "e" and s[i - 1] != "E":
                    return False
            elif ch in "eE":
                if seen_expo or not seen_digit:
                    return False
                seen_expo = True
                seen_digit = False
            elif ch == ".":
                if seen_dot or seen_expo:
                    return False
                seen_dot = True
            else:
                return False
        
        return seen_digit
```

## Nums

[Max Min]

```py
def maxMin(k, arr):
    # for a range k, find the min_diff
    arr.sort()
    res = float("inf")
    k -= 1
    for i in range(len(arr) - k):
        res = min(res, arr[i + k] - arr[i])
    
    return res
```

determine all integers that satisfy the floowing two conditions:

1. the elements of the first array are all factores of the interger being considered
2. the integer being considered is a factor of all elements of the second array

```py
def getTotalX(a, b):
    min_a = min(a)
    min_b = min(b)
    end = max(min_a, min_b)
    
    res = 0
    for i in range(1, end + 1):
        a_ok = b_ok = True
        for n in a:
            if i % n != 0:
                a_ok = False
                break
        if not a_ok:
            continue
        for n in b:
            if n % i != 0:
                b_ok = False
                break
        if not b_ok:
            continue
        res += 1
    
    return res
```

[228. Summary Ranges](https://leetcode.cn/problems/summary-ranges/)

```py
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        """
        固定左边，往右边走即可
        """
        res = []
        idx = 0
        while idx < len(nums):
            start = nums[idx]  # 固定左边
            while idx + 1 < len(nums) and nums[idx] + 1 == nums[idx + 1]:
                idx += 1
            if start != nums[idx]:
                res.append(str(start) + '->' + str(nums[idx]))
            else:
                res.append(str(nums[idx]))
            idx += 1

        return res
```

### two sum类型

[1. Two Sum](https://leetcode.cn/problems/two-sum/)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        """
        因为最后要返回idx，所以用dict()来存一下值对应的坐标
        """
        seen = dict() # {val: idx}
        
        for idx, n in enumerate(nums):
            remain = target - n
            if remain in seen:
                return [idx, seen[remain]]
            seen[n] = idx
```

[1679. Max Number of K-Sum Pairs](https://leetcode.cn/problems/max-number-of-k-sum-pairs/description/?envType=study-plan-v2&envId=leetcode-75)

```py
class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        """
        对数字进行计数，然后看自己和补数是否在字典中，如果在的话就各自-=1
        """
        freq = Counter(nums)
        count = 0
        for i in range(len(nums)):
            remain = k - nums[i]
            if freq[nums[i]] > 0 and freq[remain] > 0:
                if nums[i] == remain and freq[nums[i]] < 2:
                    continue
                freq[nums[i]] -= 1
                freq[remain] -= 1
                count += 1
        return count
```

[167. Two Sum II - Input Array Is Sorted](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```py
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        """
        ask if need to consider integer overflow
        ask if no valid output
        ask if duplicate
        ask if multiple valid output
        """
        l, r = 0, len(numbers) - 1
        
        while l < r:
            if numbers[l] + numbers[r] == target:
                l += 1
                r += 1
                return [l, r]
            elif numbers[l] + numbers[r] < target:
                l += 1
            else:
                r -= 1
        
        return [-1, -1]
```

[170. Two Sum III - Data structure design](https://leetcode.cn/problems/two-sum-iii-data-structure-design/)

```py
class TwoSum:

    def __init__(self):
        self.seen = collections.defaultdict(int)

    def add(self, number: int) -> None:
        self.seen[number] += 1

    def find(self, value: int) -> bool:
        """
        处理重复出现的情况
        同时要注意add(0), find(0)的情况
        """
        
        for n in self.seen.keys():
            remain = value - n
            if remain != n:
                if remain in self.seen:
                    return True
            elif self.seen[remain] > 1: # 处理重复出现，并且刚好是二倍
                return True
            
        
        return False
```

[653. Two Sum IV - Input is a BST](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

```py
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        """
        inorder traversal of BST is a sorted array
        """
        arr = []
        
        def dfs(node):
            if not node:
                return
            
            dfs(node.left)
            arr.append(node.val)
            dfs(node.right)
            
        dfs(root)
        
        l, r = 0, len(arr) - 1
        while l < r:
            sum = arr[l] + arr[r]
            if sum == k:
                return True
            elif sum < k:
                l += 1
            else:
                r -= 1
        
        return False
```

[15. 3Sum](https://leetcode.cn/problems/3sum/)

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        
        for i, n in enumerate(nums):
            if i > 0 and nums[i-1] == nums[i]: # avoid duplicate
                continue
            
            l, r = i + 1, len(nums) - 1
            while l < r:
                cur_sum = n + nums[l] + nums[r]
                if cur_sum < 0:
                    l += 1
                elif cur_sum > 0:
                    r -= 1
                else:
                    res.append([n, nums[l], nums[r]])
                    # keep moving to find other possibilities
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l - 1]: # avoid duplicate triplets
                        l += 1
        
        return res
```

[16. 3Sum Closest](https://leetcode.cn/problems/3sum-closest/) 好题，逻辑比较丰富

```py

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        diff = float('inf')
        nums.sort()  # 总是要排序之后才能用双指针
        for i in range(len(nums)):
            l, r = i + 1, len(nums) - 1  # 不用再往前看了，只需要往后看，因为前面看过了
            while l < r:
                cur_sum = nums[i] + nums[l] + nums[r]
                if abs(target - cur_sum) < abs(diff):
                    diff = target - cur_sum
                if cur_sum < target:
                    l += 1
                else:
                    r -= 1
                if diff == 0:
                    break
        return target - diff

```

[259. 3Sum Smaller](https://leetcode.cn/problems/3sum-smaller/)

```py
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        if len(nums) < 3: 
            return 0
        
        nums.sort()
        res = 0
        
        for i in range(len(nums)):
            res += self.twoSmaller(nums, i + 1, target - nums[i]) # 点睛之笔3: 固定nums[i]是最小的数，接下来的从i+1开始找
        
        return res

    def twoSmaller(self, nums, i, target):
        l, r = i, len(nums) - 1
        count = 0
        
        while l < r:
            cur_sum = nums[l] + nums[r]
            if cur_sum < target:
                count += r - l # 点睛之笔1：两者之间都是满足条件的
                l += 1 # 点睛之笔2：只移动右边的
            else:
                r -= 1
        return count
```

[985. Sum of Even Numbers After Queries](https://leetcode.cn/problems/sum-of-even-numbers-after-queries/)

```py
class Solution:
    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        """
        maintain the sum of even numbers in each operation. 
        因为要修改一个数，如果这个数是偶数，那么就已经加在S里了，在修改前先从S里删掉。如果是奇数那就不用管

        Time: O(max(M, N)), M is len(nums), N is len(queries)
        Space: O(N), with O(1) additional space
        """
        S = sum(x for x in nums if x % 2 == 0)
        res = []
        
        for n, i in queries:
            if nums[i] % 2 == 0:
                S -= nums[i]
            nums[i] += n
            if nums[i] % 2 == 0:
                S += nums[i]
            res.append(S)
        
        return res
```

[9. Palindrome Number](https://leetcode.cn/problems/palindrome-number/)

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 or (x > 0 and x % 10 == 0):
            return False

        result = 0
        while x > result:
            result = result * 10 + x % 10
            x = x // 10

        # for odd, x == re // 10
        return True if (x == result or x == result // 10) else False
```

[415. Add Strings](https://leetcode.cn/problems/add-strings/description/)

two pointers从后往前，用carry存进位的情况.
value = (x1 + x2 + carry) % 10,
carry = (x1 + x2 + carry) // 10.
走到头carry不为0就再append一下，最后reverse并且转换成string即可；
ord(string)返回unicode值, x = ord(string) - ord('0')就把'5'存成5到x里；
a // 10 地板除，向下取整; math.ceil(a/10)就是向上取整；
res[]存的整数反过来导出成string: ''.join(str(x) for x in res[::-1])；
要先更新val，再更新carry

时间：O(max(N1, N2)
空间：O(max(N1, N2))

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        res = []
        carry = 0
        p1 = len(num1) - 1
        p2 = len(num2) - 1
        while p1 >= 0 or p2 >= 0:
            x1 = ord(num1[p1]) - ord('0') if p1 >= 0 else 0
            x2 = ord(num2[p2]) - ord('0') if p2 >= 0 else 0
            value = (x1 + x2 + carry) % 10
            carry = (x1 + x2 + carry) // 10
            res.append(value)
            p1 -= 1
            p2 -= 1
        if carry:
            res.append(carry)
        
        return ''.join(str(x) for x in res[::-1])
```
